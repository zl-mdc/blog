---
layout: 
title: 'Node系列(一)：异步I/O'
date: 2022-01-25 11:40:01
tags: Node 异步
categories: Node
---





## 为什么要异步I/O

在跨网络的结构下，并发已经是现代编程的标准配备，，具体到实处，我们从用户体验和资源分配来说
<!-- more -->
#### （1）用户体验：

异步之所以发展起来，主要是因为浏览器对于JavaScript是单线程运行，并且与UI渲染公用一个线程，这就意味在JavaScript运行的时候，UI渲染是出于停滞状态。并且通过同步的方式读取，那么js则需要等待资源完全从服务器获取后才能执行，这期间UI将停顿，不响应用户的交互行为，影响用户体验。而采用异步的方式，js和UI渲染都不会处于等待状态，可以继续响应用户的交互行为，给用户一个鲜活的页面。

前端可以通过异步的方式消除UI阻塞现象，但是前端获取资源的速度也要取决与后端。当一个资源从两处不同的地方时，假设第一个请求的耗时为N。第二个耗时为M，如果采用同步的方式，则会耗时M+N，而采用异步的方式，耗时为Max（M,N），如果随着应用的不断增长，这就会放大异步和同步在性能方面的差异。

只有后端做出快速的响应，才能让前端的体验变好。

#### （2）资源分配：（主要是计算机资源的分配）

对于一组任务去完成，有两种主流的方法：

- 单线程串行依次执行
- 多线程并行执行

如果创建多线程的开销小于单线程，那么多线程是首选。

多线程的代价就在于创建多线程和执行期线程上下文切换的开销较大。另外，在复杂的业务当中，多线程经常面临锁，状态同步的问题，这也是多线程的诟病。但多线程在多核CPU上能有效提升CPU的利用率，这个优势也是毋庸置疑的！

在计算机资源当中，通常I/O和CPU计算之间是可以并行进行的，但是同步的编程导致的问题就是，I/O的进行会让后续的操作等待，造成资源不能很好的利用。

总之，单线程同步编程模型会因为阻塞I/O导致硬件资源等不到高效的利用，多线程编程模型，也因为编程中的死锁和线程间的状态同步等问题，让人烦恼。

**Node在这里给出了答案：利用单线程避免多线程的死锁和状态同步问题；利用异步I/O，让单线程远离阻塞，以更好地利用CPU；**

## 异步I/O的实现现状

#### （1）异步I/O与非阻塞I/O

我们学习node的时候经常听到异步，非阻塞，回调，事件等，其中异步跟非阻塞听起来可能是一回事。从实际效果而言，异步和非阻塞确实实现了并行I/O的目的。但对于计算机内核I/O而言，异步和非阻塞实际上是两回事。

计算机操作系统内核对于I/O只有两种方式：**阻塞和非阻塞**

阻塞I/O的特点：调用之后一定要等到系统内核层面完成所有的操作后，调用才结束。

**阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用**。

<!-- ![image-20220126145306005](C:\Users\14240\AppData\Roaming\Typora\typora-user-images\image-20220126145306005.png) -->



<!-- image-20220126201025369 -->

**非阻塞I/O返回后，CPU的时间片可以继续用来处理其他事务，此时的性能的提升是明显的**

但非阻塞I/O也存在一些问题。由于完整的I/O并没有完成，立即返回的并不是业务层所期待的数据，而仅仅是当前的调用状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种重复调用判断操作是否完成的技术叫做**轮询**

#### （2）现实的异步I/O

Node在*nix平台采用了libeio配合libev实现I/O部分，实现了异步I/O。**在node之后的版本，自行实现了线程池来完成异步I/O**

在window系统下，则采用了IOCP：**调用异步方法，等待I/O完成之后通知，执行回调，用户不许考虑轮询，但是其内部仍然是线程池的原理，不同之处在于这些线程池是系统内核接手管理。**

由于window系统和*nix平台的差异，Node提供了libuv作为抽象封装层，使得所有平台兼容性的判断交给这一层来完成，并保证上层的Node与下层自定义的线程池及IOCP之间各自独立。Node在编译阶段会判断平台条件，选择编译unix目录或者是win目录下的源文件到目标程序中，其架构如图：
<!-- 
![image-20220126202909536](C:\Users\14240\AppData\Roaming\Typora\typora-user-images\image-20220126202909536.png) -->



<!-- more -->



